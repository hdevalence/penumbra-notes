syntax = "proto3";

package penumbra.core.stake.v1alpha1;

import "penumbra/core/crypto/v1alpha1/crypto.proto";

// Describes a validator's configuration data.
message Validator {
  // The validator's identity verification key.
  crypto.v1alpha1.IdentityKey identity_key = 1;
  // The validator's consensus pubkey for use in Tendermint (Ed25519).
  bytes consensus_key = 2;
  // The validator's (human-readable) name.
  string name = 3;
  // The validator's website.
  string website = 4;
  // The validator's description.
  string description = 5;
  // Whether the validator is enabled or not.
  //
  // Disabled validators cannot be delegated to, and immediately begin unbonding.
  bool enabled = 8;
  // A list of funding streams describing the validator's commission.
  repeated FundingStream funding_streams = 6;
  // The sequence number determines which validator data takes priority, and
  // prevents replay attacks.  The chain only accepts new validator definitions
  // with increasing sequence numbers.
  uint32 sequence_number = 7;
  // The validator's governance key.
  crypto.v1alpha1.GovernanceKey governance_key = 9;
}

// For storing the list of keys of known validators.
message ValidatorList {
  repeated crypto.v1alpha1.IdentityKey validator_keys = 1;
}

// A portion of a validator's commission.
message FundingStream {
  message ToAddress {
    // The destination address for the funding stream.
    string address = 1;
    // The portion of the staking reward for the entire delegation pool
    // allocated to this funding stream, specified in basis points.
    uint32 rate_bps = 2;
  }

  message ToDao {
    // The portion of the staking reward for the entire delegation pool
    // allocated to this funding stream, specified in basis points.
    uint32 rate_bps = 2;
  }

  // The recipient of the funding stream.
  oneof recipient {
    ToAddress to_address = 1;
    ToDao to_dao = 2;
  }
}

// Describes the reward and exchange rates and voting power for a validator in some epoch.
message RateData {
  crypto.v1alpha1.IdentityKey identity_key = 1;
  uint64 epoch_index = 2;
  uint64 validator_reward_rate = 4;
  uint64 validator_exchange_rate = 5;
}

// Describes the base reward and exchange rates in some epoch.
message BaseRateData {
  uint64 epoch_index = 1;
  uint64 base_reward_rate = 2;
  uint64 base_exchange_rate = 3;
}

// Describes the current state of a validator on-chain
message ValidatorStatus {
  crypto.v1alpha1.IdentityKey identity_key = 1;
  ValidatorState state = 2;
  uint64 voting_power = 3;
  BondingState bonding_state = 4;
}

// Describes the unbonding state of a validator's stake pool.
message BondingState {
  enum BondingStateEnum {
    BONDING_STATE_ENUM_UNSPECIFIED = 0;
    BONDING_STATE_ENUM_BONDED = 1;
    BONDING_STATE_ENUM_UNBONDING = 2;
    BONDING_STATE_ENUM_UNBONDED = 3;
  }
  BondingStateEnum state = 1;
  optional uint64 unbonding_epoch = 2;
}

// Describes the state of a validator
message ValidatorState {
  enum ValidatorStateEnum {
    VALIDATOR_STATE_ENUM_UNSPECIFIED = 0;
    VALIDATOR_STATE_ENUM_INACTIVE = 1;
    VALIDATOR_STATE_ENUM_ACTIVE = 2;
    VALIDATOR_STATE_ENUM_JAILED = 3;
    VALIDATOR_STATE_ENUM_TOMBSTONED = 4;
    VALIDATOR_STATE_ENUM_DISABLED = 5;
  }
  ValidatorStateEnum state = 1;
}


// Combines all validator info into a single packet.
message ValidatorInfo {
  Validator validator = 1;
  ValidatorStatus status = 2;
  RateData rate_data = 3;
}

// A transaction action (re)defining a validator.
message ValidatorDefinition {
  // The configuration data for the validator.
  Validator validator = 1;
  // A signature by the validator's identity key over the validator data.
  bytes auth_sig = 2;
}

// A transaction action adding stake to a validator's delegation pool.
message Delegate {
  // The identity key of the validator to delegate to.
  crypto.v1alpha1.IdentityKey validator_identity = 1;
  // The index of the epoch in which this delegation was performed.
  // The delegation takes effect in the next epoch.
  uint64 epoch_index = 2;
  // The delegation amount, in units of unbonded stake.
  // TODO: use flow aggregation to hide this, replacing it with bytes amount_ciphertext;
  crypto.v1alpha1.Amount unbonded_amount = 3;
  // The amount of delegation tokens produced by this action.
  //
  // This is implied by the validator's exchange rate in the specified epoch
  // (and should be checked in transaction validation!), but including it allows
  // stateless verification that the transaction is internally consistent.
  crypto.v1alpha1.Amount delegation_amount = 4;
}

// A transaction action withdrawing stake from a validator's delegation pool.
message Undelegate {
  // The identity key of the validator to undelegate from.
  crypto.v1alpha1.IdentityKey validator_identity = 1;
  // The index of the epoch in which this undelegation was performed.
  uint64 start_epoch_index = 2;
  // The amount to undelegate, in units of unbonding tokens.
  crypto.v1alpha1.Amount unbonded_amount = 3;
  // The amount of delegation tokens consumed by this action.
  //
  // This is implied by the validator's exchange rate in the specified epoch
  // (and should be checked in transaction validation!), but including it allows
  // stateless verification that the transaction is internally consistent.
  crypto.v1alpha1.Amount delegation_amount = 4;
}

// A transaction action finishing an undelegation, converting (slashable)
// "unbonding tokens" to (unslashable) staking tokens.
message UndelegateClaim {
  UndelegateClaimBody body = 1;
  bytes proof = 2;
}

message UndelegateClaimBody {
  // The identity key of the validator to finish undelegating from.
  crypto.v1alpha1.IdentityKey validator_identity = 1;
  // The epoch in which unbonding began, used to verify the penalty.
  uint64 start_epoch_index = 2;
  // The penalty applied to undelegation, in bps^2 (10e-8).
  // In the happy path (no slashing), this is 0.
  Penalty penalty = 3;
  // The action's contribution to the transaction's value balance.
  crypto.v1alpha1.BalanceCommitment balance_commitment = 4;
}

message UndelegateClaimPlan {
  // The identity key of the validator to finish undelegating from.
  crypto.v1alpha1.IdentityKey validator_identity = 1;
  // The epoch in which unbonding began, used to verify the penalty.
  uint64 start_epoch_index = 2;
  // The penalty applied to undelegation, in bps^2 (10e-8).
  // In the happy path (no slashing), this is 0.
  Penalty penalty = 4;
  // The amount of unbonding tokens to claim.
  // This is a bare number because its denom is determined by the preceding data.
  crypto.v1alpha1.Amount unbonding_amount = 5;
  // The blinding factor to use for the balance commitment.
  bytes balance_blinding = 6;
}

// A list of pending delegations and undelegations.
message DelegationChanges {
  repeated Delegate delegations = 1;
  repeated Undelegate undelegations = 2;
}

// Track's a validator's uptime.
message Uptime {
  uint64 as_of_block_height = 1;
  uint32 window_len = 2;
  bytes bitvec = 3;
}

// Tracks our view of Tendermint's view of the validator set, so we can keep it
// from getting confused.
message CurrentConsensusKeys {
  repeated crypto.v1alpha1.ConsensusKey consensus_keys = 1;
}

// Tracks slashing penalties applied to a validator in some epoch.
message Penalty {
  uint64 inner = 1;
}
