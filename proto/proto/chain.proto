syntax = "proto3";
package penumbra.chain;

import "crypto.proto";

// Global chain configuration data, such as chain ID, epoch duration, etc.
message ChainParams {
  // The identifier of the chain.
  string chain_id = 1;
  // The duration of each epoch, in number of blocks.
  uint64 epoch_duration = 2;
  // The number of epochs an unbonding note for before being released.
  uint64 unbonding_epochs = 3;
  // The maximum number of validators in the consensus set.
  uint64 active_validator_limit = 4;
  // The penalty expressed in base points to be applied to slashed validators' rates.
  uint64 slashing_penalty = 5;
  /// Whether IBC (forming connections, processing IBC packets) is enabled.
  bool ibc_enabled = 6;
  /// Whether inbound ICS-20 transfers are enabled
  bool inbound_ics20_transfers_enabled = 7;
  /// Whether outbound ICS-20 transfers are enabled
  bool outbound_ics20_transfers_enabled = 8;
}

// Information about a given asset at a given time (as specified by block
// height). Currently this only contains the total supply.
message AssetInfo {
  crypto.AssetId asset_id = 1;
  crypto.Denom denom = 2;
  uint64 as_of_block_height = 3;
  uint64 total_supply = 4;
}

// Contains the minimum data needed to update client state.
message CompactBlock {
  uint64 height = 1;
  // Fragments of new notes.
  repeated CompactOutput fragments = 2;
  // Nullifiers identifying spent notes.
  repeated bytes nullifiers = 3;
}

// The minimum data needed to identify a new note.
message CompactOutput {
  // The note commitment for the output note. 32 bytes.
  bytes note_commitment = 2;
  // The encoding of an ephemeral public key. 32 bytes.
  bytes ephemeral_key = 3;
  // An encryption of the newly created note.
  // 132 = 1(type) + 11(d) + 8(amount) + 32(asset_id) + 32(rcm) + 32(pk_d) + 16(MAC) bytes.
  bytes encrypted_note = 4;
}
