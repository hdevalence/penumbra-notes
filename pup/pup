#!/usr/bin/env bash
set -eo pipefail

BASE_DIR="${XDG_CONFIG_HOME:-$HOME}"
PUP_DIR="${PUP_DIR-"$BASE_DIR/.pup"}"
PUP_BIN_DIR="$PUP_DIR/bin"

main() {
  need_cmd git
  need_cmd curl
  need_cmd jq

  while [[ -n $1 ]]; do
    case $1 in
      --)           shift; break;;
      
      --pcli)       PCLI=1;;

      -h|--help)
        usage
        exit 0
        ;;
      *)
        warn "unknown option: $1"
        usage
        exit 1
    esac; shift
  done

  PUP_REPO=${PUP_REPO=penumbra-zone/penumbra}

  if [[ "$PCLI" == "1" ]]; then
    uninstall_if_exists "pcli"
    fetch_latest_version
    determine_platform_and_architecture
    build_download_url
    download_and_install "pcli"
  else
    sayf "done"
  fi
}

usage() {
  cat 1>&2 <<EOF
The installer for Penumbra.

Update to a specific Penumbra release with ease.

USAGE:
    pup <OPTIONS>

OPTIONS:
    -h, --help Print help information
EOF
}

say() {
  printf "%s" "$1"
}

sayf() {
  printf "%s\n" "$1"
}

warn() {
  sayf "warning: ${1}" >&2
}

err() {
  sayf "$1" >&2
  exit 1
}

need_cmd() {
  if ! check_cmd "$1"; then
    err "need '$1' (command not found)"
  fi
}

check_cmd() {
  command -v "$1" &>/dev/null
}

# Run a command that should never fail. If the command fails execution
# will immediately terminate with an error showing the failing command.
ensure() {
  if ! "$@"; then err "command failed: $*"; fi
}

determine_platform_and_architecture() {
  OS=$(uname -s)
  ARCH=$(uname -m)

  case $OS in
    Linux) OS="unknown-linux-gnu";;
    Darwin) OS="apple-darwin";;
    *) err "Unsupported operating system: $OS";;
  esac

  case $ARCH in
    arm64) ARCH="aarch64";;
    x86_64) ;;
    *) err "Unsupported architecture: $ARCH";;
  esac
}

build_download_url() {
  DOWNLOAD_URL="https://github.com/${PUP_REPO}/releases/download/${PUP_TAG}/pcli-${ARCH}-${OS}.tar.xz"
}

uninstall_if_exists() {
  TOOL=$1
  BIN_PATH="$PUP_BIN_DIR/${TOOL}"

  if [ -f "$BIN_PATH" ]; then
    say "Existing installation of ${TOOL} found. Uninstalling..."
    ensure rm -f "$BIN_PATH"
  fi
}

download_and_install() {
  TOOL=$1
  if [[ -z "$DOWNLOAD_URL" || -z "$TOOL" ]]; then
    err "Download URL or tool name is not set. Cannot proceed."
  fi

  # Create and switch to a temporary directory
  TEMP_DIR=$(mktemp -d)
  pushd "$TEMP_DIR" >/dev/null

  sayf "Downloading ${TOOL}..."
  ensure curl -sSfLO "$DOWNLOAD_URL"

  sayf "Extracting ${TOOL}..."
  if [[ "$DOWNLOAD_URL" =~ \.tar\.xz$ ]]; then
    ensure tar -xJf "${TOOL}-${ARCH}-${OS}.tar.xz"
  elif [[ "$DOWNLOAD_URL" =~ \.zip$ ]]; then
    ensure unzip "${TOOL}-${ARCH}-${OS}.zip"
  else
    err "Unsupported archive format."
  fi

  # Correctly identify the binary's path after extraction
  BINARY_PATH=$(find . -type f -name "$TOOL" | head -n 1)
  if [ -z "$BINARY_PATH" ]; then
    err "Failed to find the $TOOL binary after extraction."
  fi

  sayf "Moving ${TOOL} binary to $PUP_BIN_DIR..."
  ensure mkdir -p "$PUP_BIN_DIR"
  ensure mv "$BINARY_PATH" "$PUP_BIN_DIR/"

  popd >/dev/null
  ensure rm -rf "$TEMP_DIR"

  verify_installation "$TOOL"
}

verify_installation() {
  TOOL=$1

  # Use awk to skip the tool name and directly compare version strings including the 'v' prefix
  INSTALLED_VERSION=$(PCLI_UNLEASH_DANGER=true ${TOOL} --version | awk '{print $2}')

  if [[ "v$INSTALLED_VERSION" == "$PUP_TAG" ]]; then
    sayf "Verification successful: ${TOOL} $INSTALLED_VERSION installed."
  else
    err "Verification failed for ${TOOL}: Version mismatch or installation error. Expected $PUP_TAG, got $INSTALLED_VERSION"
  fi
}

fetch_latest_version() {
  PUP_TAG=$(curl -s "https://api.github.com/repos/${PUP_REPO}/releases/latest" | jq -r .tag_name)
  if [[ "$PUP_TAG" == "null" ]]; then
    err "Could not fetch the latest version number. Please ensure the repository exists and has releases."
  fi
}

main "$@"